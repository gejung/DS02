# -*- coding: utf-8 -*-
"""DS_002_linear_algebra_template.ipynb copy

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xfmAmerdOGuCfXD6CP6QPcJcMqfio8Yf

# Template for linear_algebra.py

This template contains function declarations and a handful of assert tests for `linear_algebra.py`. Edit the return statements in each function until they pass each assertion. Refer to Chapter 4 from "Data Science from Scratch" for help.
"""

from typing import List

Vector = List[float]

def add(v: Vector, w: Vector) -> Vector:
    """Adds corresponding elements"""
    assert len(v) == len(w), "vectors must be the same length"
    return [v_i + w_i for v_i, w_i in zip(v, w)]
    


def subtract(v: Vector, w: Vector) -> Vector:
    """Subtracts corresponding elements"""
    assert len(v) == len(w), "vectors must be the same length"

    return [v_i - w_i for v_i, w_i in zip(v, w)]


def vector_sum(vectors: List[Vector]) -> Vector:
    """Sums all corresponding elements"""
    # Check that vectors is not empty
    assert vectors, "no vectors provided!"

    # Check the vectors are all the same size
    num_elements = len(vectors[0])
    assert all(len(v) == num_elements for v in vectors), "different sizes!"

    # the i-th element of the result is the sum of every vector[i]
    return [sum(vector[i] for vector in vectors)
            for i in range(num_elements)]


def scalar_multiply(c: float, v: Vector) -> Vector:
    """Multiplies every element by c"""
    # Like add() and subtract() 
    return [c * v_i for v_i in v]


def vector_mean(vectors: List[Vector]) -> Vector:
    """Computes the element-wise average"""
    n = len(vectors)
    return scalar_multiply(1/n, vector_sum(vectors))


def dot(v: Vector, w: Vector) -> float:
    """Computes v_1 * w_1 + ... + v_n * w_n"""
    assert len(v) == len(w), "vectors must be same length"

    return sum(v_i * w_i for v_i, w_i in zip(v, w))


def sum_of_squares(v: Vector) -> float:
    """Returns v_1 * v_1 + ... + v_n * v_n"""
    return dot(v, v)


import math

def magnitude(v: Vector) -> float:
    """Returns the magnitude (or length) of v"""
    return math.sqrt(sum_of_squares(v))   # math.sqrt is square root function


def squared_distance(v: Vector, w: Vector) -> float:
    """Computes (v_1 - w_1) ** 2 + ... + (v_n - w_n) ** 2"""
    return sum_of_squares(subtract(v, w))

# def distance(v: Vector, w: Vector) -> float:
#     """Computes the distance between v and w"""
#     return math.sqrt(squared_distance(v, w))

# This is possibly clearer if we write it as (the equivalent):
def distance(v: Vector, w: Vector) -> float:  # type: ignore
    return magnitude(subtract(v, w))

assert add([1, 2, 3], [10,9,8]) == [11,11,11], "something's wrong with add()"
assert subtract([11,11,11], [1, 2, 3]) == [10,9,8], "trouble with subtract()"
assert vector_sum([[3,4], [5,6], [7,8]]) == [15, 18], "vector_sum() problem"
assert vector_mean([[1, 2], [3, 4], [5, 6]]) == [3, 4], "oopsie vector_mean()"
assert dot([1, 2, 3], [4, 5, 6]) == 32, "dot() issue"  # 1 * 4 + 2 * 5 + 3 * 6
assert sum_of_squares([1, 2, 3]) == 14, "sum_of_squares() fail"  # 1 * 1 + 2 * 2 + 3 * 3
assert magnitude([3, 4]) == 5, "issue with magnitude()"

"""# Matrices
A matrix is a two-dimensional collection of numbers. We will represent matrices as lists of lists, with each inner list having the same size and representing a row of the matrix. If A is a matrix, then A[i][j] is the element in the ith row and the jth column. Per mathematical convention, we will frequently use capital letters to represent matri‐ ces. 

For example:
"""

# Another type alias
Matrix = List[List[float]]

A = [[1, 2, 3], # A has 2 rows and 3 columns
    [4, 5, 6]]
""
B = [[1, 2], # B has 3 rows and 2 columns
     [3, 4],
     [5, 6]]

from typing import Tuple

def shape(A: Matrix) -> Tuple[int, int]:
  """Returns (# of rows of A, # of columns of A)"""
  num_rows = len(A)
  num_cols = len(A[0]) if A else 0 # number of elements in first row 
  return num_rows, num_cols

assert shape([[1, 2, 3], [4, 5, 6]]) == (2, 3) # 2 rows, 3 columns

# If a matrix has n rows and k columns, we will refer to it as an n × k matrix. 
# We can (and sometimes will) think of each row of an n × k matrix as a vector 
# of length k, and each column as a vector of length n:

def get_row(A: Matrix, i: int) -> Vector:
  """Returns the i-th row of A (as a Vector)"""
  return A[i] # A[i] is already the ith row

def get_column(A: Matrix, j: int) -> Vector: 
  """Returns the j-th column of A (as a Vector)""" 
  return [A_i[j] for A_i in A] # jth element of row A_i
  # for A_i in A] # for each row A_i

from typing import Callable

def make_matrix(num_rows: int, num_cols: int,
                    entry_fn: Callable[[int, int], float]) -> Matrix:
    #"""
#Returns a num_rows x num_cols matrix
#whose (i,j)-th entry is entry_fn(i, j)
#"""
    return [[entry_fn(i, j) # given i, create a list
    for j in range(num_cols)] # [entry_fn(i, 0), ... ] for i in range(num_rows)] # create one list for each i

"""A simulation to demonstrate that if you wait for two heads in a row, it takes 6 flips on average, while you wait for a heads then a tails, it takes 4 flips on average.

https://www.codechef.com/wiki/tutorial-expectation
https://jcbain.github.io/blog/coin-flip-probs/

> The first is a function to simulate flipping a fair coin…

> Then I need a function to flip the coin multiple times and to stop only when a certain sequence of sides were met. In other words, stop when two heads were flipped in a row. From this, I want the number of times it took to achieve this sequence to be returned.




"""

import numpy as np

def flip_coin():
    """Simulate flipping a coin.
    
    Returns
    -------
    str
        "H" for heads/ "T" for tails.
    """
    flip = np.random.binomial(1, .5, 1)
    if flip[0] == 1:
        side = "H"
    else:
        side = "T"
    return side


def flip_condition(stop_condition=['H', 'T'], print_opt=False):
    """Flip coin until flip pattern is met.
    
    Parameters
    ----------
    stop_condition: list
        The sequence of flips to be matched before flipping stops.
    
    print_opt: bool
        Option to print the sequence of flips.
        
    Returns
    -------
    int
        The number of flips it took to match the pattern.
    """
    flip_list = []
    
    current_index = 0
    current_condition = None
    while current_condition != stop_condition:
        flip_list.append(flip_coin())
        if len(flip_list) >= len(stop_condition):
            current_condition = [flip_list[i] for i in range(current_index - len(stop_condition) +1 , current_index + 1)]
        else:
            pass
        current_index +=1
        
    if print_opt:
        print(flip_list)
    return current_index

mean_ht = np.mean([flip_condition(['H', 'T']) for i in range(10000)])
mean_hh = np.mean([flip_condition(['H','H']) for i in range(10000)])

print("Average # of flips to achieve heads and then heads again: {}".format(mean_hh))
print("Average # of flips to achieve heads and then tails: {}".format(mean_ht))

np.mean([flip_condition(['H', 'T', 'H']) for i in range(10000)])

# 9.9231

np.mean([flip_condition(['H','H','H','H','H']) for i in range(10000)])

np.mean([flip_condition(['T','T','T']) for i in range(10000)])

